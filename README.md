# Redux (Udemy Stephen Grider)

- **Redux** is the data contained in the application 
- **React** is the views contained in the application 

#### Difference with other libraries like Angular, Backbone and Flux: ####
- Redux: centralized data in a single object referred to as the **state** (application level state containing all the data of the application)
- Whereas other libraries has several collections. e.g. Backbone has many collections and Flux has different stores. 

_______________________________________________

### Reducers

- A **reducer** is a **function** that returns a piece of the application's state 
- Because an application can have many different pieces of state (key value pair: a key of state matching with a value of state), we can have many different reducers 
- Application State: generated by Reducers 

#### 1. Create and export a reducer (we have to export in order to use it in other parts of our application)
- reducer_books.js:

```javascript
export default function() {
	return [
		{ title: 'Javascript: The Good Parts' }, 
		{ title: "Harry Potter" }, 
		{ title: "The Dark Tower" },
		{ title: "Eloquent Ruby" }
	]
}
```

#### 2. Wire it to our Application 
- index.js: 
```javascript
import { combineReducers } from 'redux';
import BooksReducer from './reducer_books'; 

const rootReducer = combineReducers({
	books: BooksReducer
});

export default rootReducer;

```

_______________________________________________

### Containers - Connecting Redux to React 

**Redux** and **React** are separate libraries - no intrinsic connection between the two. 
Connecting these 2 libraries (react and redux) is done with another library called react-redux 
- The **react-redux** library forms the bridge between the two separate libraries (React and Redux) 

React-redux usage: 

- Define one of the components (promote it) to be a container. 
- A **container** is a React component that has a **direct connection** to the state managed by Redux. 
- A container is referred to as **smart components** (has connection to Redux) as opposed to a dumb component (no connection to Redux)

- Create a new folder in src folder called 'containers'
- Move book-list.js from components folder into containers folder 

#### Which component do we want to return into a container? 
- In general, the most parent component that cares about a particular piece of state 
- Only the parent needs to be connected (child does not need to)

_______________________________________________

### Containers - Implementation of a Container Class 

- components/app.js: (import BookList container and render it so that it appears on the App view)
```javascript
import React, { Component } from 'react';
import BookList from '../containers/book-list';

export default class App extends Component {
  render() {
    return (
      <div>
      <BookList />
      </div>
    );
  }
}
```

- containers/book-list.js: (this is the container )
```javascript
import { connect } from 'react-redux'; //import connect function from react-redux

class BookList extends Component {
	...
}

function mapStateToProps(state) {
	return {
		books: state.books
	}; 
}

export default connect(mapStateToProps)(BookList); 
// connect(function)(component) and it produces a container, which is aware of the state contained by redux 
```
#### function mapStateToProps(state)
- This function is the glue between react and redux 
- Takes in the application state as an arguement 
- Whatever gets returned from here will show up as props inside of BookList container above 

#### export default connect(mapStateToProps)(BookList)
- connect(function)(component) and it produces a container, which is aware of the state contained by redux 


- Whenever our app state changes, the container(BookList) will **automatically re-render**
- Whenever the app state changes, the object in the state function **will be assigned as props** to the container component (BookList)

_______________________________________________

### Containers and Reducers Review

- Redux serves to **construct** the application state 
- Whereas React serves to provide the **views** to display that state
- the two libraries are inherently disconnected and it is only throught the use of react-redux that we get a connection between the two
- Our application state is generated by reducer functions 

- In the example, we created a reducer called reducer-books.js which returns an array of books 
- The array contains a list of objects 
- We added the BooksReducer (reducer_books.js) to the reducer/index.js to our combineReducers call: 

```javascript
import { combineReducers } from 'redux';
import BooksReducer from './reducer_books'; 

const rootReducer = combineReducers({
	books: BooksReducer
});

export default rootReducer;
```

- By doing the above, it add a key-value (books: BooksReducer) to our global application state whereby the key is **books** and the value is our BooksReducer which is in this case our array of books
- book-list.js started off as a component but we decided it needs to be aware of state and hence it was promoted to a container by 
1) import { connect } from 'react-redux'
```javascript
import { connect } from 'react-redux';
```
2) define function mapStateToProps(state)
```javascript
function mapStateToProps(state) 
```
3) hook our component to (mapStateToProps) function using: 
```javascript
export default connect(mapStateToProps)(BookList)
```
_______________________________________________

### Actions and Action Creators

- Currently the BooksReducer returns the same array (no ability to change the state overtime)
- We need to allow state to be dynamic and changeable: this is what **actions & action creators** are for 

#### Lifecycle of an Action in a Redux applcation 
1) User clicks a button: calls an action creator 
2) Action Creator is a function that returns an action object (has a type and payload) 
3) That Action is automatically sent to all reducers 
- switch statement based on action type
- if type matches, reducer returns new value of state 
4) All reducers process the action and returns a new state (or not). 
5) New state is assembled and notifies containers of the changes to state.  
6) On notification, container will re-render with new props 
7) Process repeats

_______________________________________________

### Binding Action Creators 


- Define and create Action Creator in **src/actions/index.js**:

```javascript
export function selectBook(book) {
	console.log('A book has been selected:', book.title); 
}
```

- src/containers/book-list.js: 
```javascript
import { selectBook } from '../actions/index';
import { bindActionCreators } from 'redux'; 
...
function mapDispatchToProps(dispatch) {
	return bindActionCreators({ selectBook: selectBook }, dispatch); 
}

export default connect(mapStateToProps, mapDispatchToProps)(BookList);
```
- import selectBook function (action creator) 
- **bindActionCreators** is a function that ensures that the action generated by the action creator ends up flowing through all the reducers 

- Whenever **selectBook** is called, the result should be passed to all reducers 
- Anything returned from this function will **end up as props on the BookList container** 
- Now we can use **this.props.selectBook** in the above container and this will call our selectBook action creator

- We promote BookList from a component to a container as it needs to know about this new dispatch method, selectBook
- Makes it available as a **prop**

_______________________________________________

### Creating an Action 

- Connect action creator to the BookList container: 
```javascript
class BookList extends Component {
	renderList() {
		return this.props.books.map((book) => {
			return (
				<li 
					key={book.title} 
					onClick={() => this.props.selectBook(book)}
					className="list-group-item">
					{book.title}
				</li>
			);
		});
	}
```
- onClick, it will call selectBook action creator: 
```javascript
export function selectBook(book) {
	console.log('A book has been selected:', book.title); 
}
```
- If the console.log output is shown, it means that we have succesfully connected our action creator to the container 

- Now, we want to create a usable action instead of just a console.log statement
- **src/actions/index.js**: 


_______________________________________________

### Creating an Action 

```javascript
export function selectBook(book) {
	return {
		type: 'BOOK_SELECTED', 
		payload: book 
	}; 
}
```
- **selectBook** is an ActionCreator, it needs to **return an action**, an object with **type** property
- **type** is always in uppercase and usually a string
- **payload** is a piece of data that describes more information about the action undertaken 

_______________________________________________

### Consuming Actions in Reducers 

- Previously we created an Action which will be automatically sent to all reducers 
- So now, we create the reducer (naming it as ActiveBook Reducer)

- src/reducers/reducer_active_books.js: 
```javascript
export default function(state = null, action) {
	switch(action.type) {
	case 'BOOK_SELECTED': 
		return action.payload; 
	}
	return state; 
}
```

- In the above, if the action has a **type matching** 'BOOK_SELECTED', return action.payload (book), 
- Else, return the current state
- 'State' argument is **not** APPLICATION state, it refers only to the state that **this reducer** is responsible for 
- All reducers get 2 arguments: **state** and **action** 
```javascript
export default function(state = null, action) {
}
```
- When we boot the app up and the user has not clicked on anything, undefined will be returned
- Redux does not allow us to return undefined and will throw an error
- We have to set the **default state** as **null** (above) 
- Important to **never mutate our current state** to provide a new version of the state 
- The object that we return from our reducer should always be 100% fresh and clean 

- Lastly, our reducer needs to be connected into the **combineReducers()** statement in src/reduers/index.js: 
```javascript
import ActiveBook from './reducer_active_book';

const rootReducer = combineReducers({
	books: BooksReducer,
	activeBook: ActiveBook
});

export default rootReducer;
```

- Remember that any key (e.g. **activeBook**) that we provide to **combineReducers()** ends up as a key on our **global state**

_______________________________________________

### Consuming Actions in Reducers Continued 

- Now to create a Book detail view to be rendered whenever a book is selected 
- Need to decide if we want to make a component or container (when we want to touch redux state directly)
- Book Detail will care about the active book and hence it should be a container 


































