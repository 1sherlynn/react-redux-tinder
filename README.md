# Redux Part 1 (Udemy Stephen Grider)

- **Redux** is the data contained in the application 
- **React** is the views contained in the application 

#### Difference with other libraries like Angular, Backbone and Flux: ####
- Redux: centralized data in a single object referred to as the **state** (application level state containing all the data of the application)
- Whereas other libraries has several collections. e.g. Backbone has many collections and Flux has different stores. 

_______________________________________________

### Reducers

- A **reducer** is a **function** that returns a piece of the application's state 
- Because an application can have many different pieces of state (key value pair: a key of state matching with a value of state), we can have many different reducers 
- Application State: generated by Reducers 

#### 1. Create and export a reducer (we have to export in order to use it in other parts of our application)
- reducer_books.js:

```javascript
export default function() {
	return [
		{ title: 'Javascript: The Good Parts' }, 
		{ title: "Harry Potter" }, 
		{ title: "The Dark Tower" },
		{ title: "Eloquent Ruby" }
	]
}
```

#### 2. Wire it to our Application 
- index.js: 
```javascript
import { combineReducers } from 'redux';
import BooksReducer from './reducer_books'; 

const rootReducer = combineReducers({
	books: BooksReducer
});

export default rootReducer;

```

_______________________________________________

### Containers - Connecting Redux to React 

**Redux** and **React** are separate libraries - no intrinsic connection between the two. 
Connecting these 2 libraries (react and redux) is done with another library called react-redux 
- The **react-redux** library forms the bridge between the two separate libraries (React and Redux) 

React-redux usage: 

- Define one of the components (promote it) to be a container. 
- A **container** is a React component that has a **direct connection** to the state managed by Redux. 
- A container is referred to as **smart components** (has connection to Redux) as opposed to a dumb component (no connection to Redux)

- Create a new folder in src folder called 'containers'
- Move book-list.js from components folder into containers folder 

#### Which component do we want to return into a container? 
- In general, the most parent component that cares about a particular piece of state 
- Only the parent needs to be connected (child does not need to)

_______________________________________________

### Containers - Implementation of a Container Class 

- components/app.js: (import BookList container and render it so that it appears on the App view)
```javascript
import React, { Component } from 'react';
import BookList from '../containers/book-list';

export default class App extends Component {
  render() {
    return (
      <div>
      <BookList />
      </div>
    );
  }
}
```

- containers/book-list.js: (this is the container )
```javascript
import { connect } from 'react-redux'; //import connect function from react-redux

class BookList extends Component {
	...
}

function mapStateToProps(state) {
	return {
		books: state.books
	}; 
}

export default connect(mapStateToProps)(BookList); 
// connect(function)(component) and it produces a container, which is aware of the state contained by redux 
```
#### function mapStateToProps(state)
- This function is the glue between react and redux 
- Takes in the application state as an arguement 
- Whatever gets returned from here will show up as props inside of BookList container above 

#### export default connect(mapStateToProps)(BookList)
- connect(function)(component) and it produces a container, which is aware of the state contained by redux 


- Whenever our app state changes, the container(BookList) will **automatically re-render**
- Whenever the app state changes, the object in the state function **will be assigned as props** to the container component (BookList)

_______________________________________________

### Containers and Reducers Review

- Redux serves to **construct** the application state 
- Whereas React serves to provide the **views** to display that state
- the two libraries are inherently disconnected and it is only throught the use of react-redux that we get a connection between the two
- Our application state is generated by reducer functions 

- In the example, we created a reducer called reducer-books.js which returns an array of books 
- The array contains a list of objects 
- We added the BooksReducer (reducer_books.js) to the reducer/index.js to our combineReducers call: 

```javascript
import { combineReducers } from 'redux';
import BooksReducer from './reducer_books'; 

const rootReducer = combineReducers({
	books: BooksReducer
});

export default rootReducer;
```

- By doing the above, it add a key-value (books: BooksReducer) to our global application state whereby the key is **books** and the value is our BooksReducer which is in this case our array of books
- book-list.js started off as a component but we decided it needs to be aware of state and hence it was promoted to a container by 
1) import { connect } from 'react-redux'
```javascript
import { connect } from 'react-redux';
```
2) define function mapStateToProps(state)
```javascript
function mapStateToProps(state) 
```
3) hook our component to (mapStateToProps) function using: 
```javascript
export default connect(mapStateToProps)(BookList)
```
_______________________________________________

### Actions and Action Creators

- Currently the BooksReducer returns the same array (no ability to change the state overtime)
- We need to allow state to be dynamic and changeable: this is what **actions & action creators** are for 

#### Lifecycle of an Action in a Redux applcation 
1) User clicks a button: calls an action creator 
2) Action Creator is a function that returns an action object (has a type and payload) 
3) That Action is automatically sent to all reducers 
- switch statement based on action type
- if type matches, reducer returns new value of state 
4) All reducers process the action and returns a new state (or not). 
5) New state is assembled and notifies containers of the changes to state.  
6) On notification, container will re-render with new props 
7) Process repeats

_______________________________________________

### Binding Action Creators 


- Define and create Action Creator in **src/actions/index.js**:

```javascript
export function selectBook(book) {
	console.log('A book has been selected:', book.title); 
}
```

- src/containers/book-list.js: 
```javascript
import { selectBook } from '../actions/index';
import { bindActionCreators } from 'redux'; 
...
function mapDispatchToProps(dispatch) {
	return bindActionCreators({ selectBook: selectBook }, dispatch); 
}

export default connect(mapStateToProps, mapDispatchToProps)(BookList);
```
- import selectBook function (action creator) 
- **bindActionCreators** is a function that ensures that the action generated by the action creator ends up flowing through all the reducers 

- Whenever **selectBook** is called, the result should be passed to all reducers 
- Anything returned from this function will **end up as props on the BookList container** 
- Now we can use **this.props.selectBook** in the above container and this will call our selectBook action creator

- We promote BookList from a component to a container as it needs to know about this new dispatch method, selectBook
- Makes it available as a **prop**

_______________________________________________

### Creating an Action 

- Connect action creator to the BookList container: 
```javascript
class BookList extends Component {
	renderList() {
		return this.props.books.map((book) => {
			return (
				<li 
					key={book.title} 
					onClick={() => this.props.selectBook(book)}
					className="list-group-item">
					{book.title}
				</li>
			);
		});
	}
```
- onClick, it will call selectBook action creator: 
```javascript
export function selectBook(book) {
	console.log('A book has been selected:', book.title); 
}
```
- If the console.log output is shown, it means that we have succesfully connected our action creator to the container 

- Now, we want to create a usable action instead of just a console.log statement
- **src/actions/index.js**: 


_______________________________________________

### Creating an Action 

```javascript
export function selectBook(book) {
	return {
		type: 'BOOK_SELECTED', 
		payload: book 
	}; 
}
```
- **selectBook** is an ActionCreator, it needs to **return an action**, an object with **type** property
- **type** is always in uppercase and usually a string
- **payload** is a piece of data that describes more information about the action undertaken 

_______________________________________________

### Consuming Actions in Reducers 

- Previously we created an Action which will be automatically sent to all reducers 
- So now, we create the reducer (naming it as ActiveBook Reducer)

- src/reducers/reducer_active_books.js: 
```javascript
export default function(state = null, action) {
	switch(action.type) {
	case 'BOOK_SELECTED': 
		return action.payload; 
	}
	return state; 
}
```

- In the above, if the action has a **type matching** 'BOOK_SELECTED', return action.payload (book), 
- Else, return the current state
- 'State' argument is **not** APPLICATION state, it refers only to the state that **this reducer** is responsible for 
- All reducers get 2 arguments: **state** and **action** 
```javascript
export default function(state = null, action) {...}
```
- When we boot the app up and the user has not clicked on anything, undefined will be returned
- Redux does not allow us to return undefined and will throw an error
- We have to set the **default state** as **null** (above) 
- Important to **never mutate our current state** to provide a new version of the state 
- The object that we return from our reducer should always be 100% fresh and clean 

- Lastly, our reducer needs to be connected into the **combineReducers()** statement in src/reduers/index.js: 
```javascript
import ActiveBook from './reducer_active_book';

const rootReducer = combineReducers({
	books: BooksReducer,
	activeBook: ActiveBook
});

export default rootReducer;
```

- Remember that any key (e.g. **activeBook**) that we provide to **combineReducers()** ends up as a key on our **global state**

_______________________________________________

### Consuming Actions in Reducers Continued 

- Now to create a Book detail view to be rendered whenever a book is selected 
- Need to decide if we want to make a component or container (when we want to touch redux state directly)
- Book Detail will care about the active book and hence it should be a container 

- src/actions/index.js: 
```javascript
import React, { Component } from 'react'; 
import { connect } from 'react-redux'; 

class BookDetail extends Component {...}

function mapStateToProps(state) {
	return {
		book: state.activeBook
	}; 
}

export default connect(mapStateToProps)(BookDetail); 
```

- Connect to store: STEP 1/3: 
```javascript
import { connect } from 'react-redux'; 
```
- Connect to store: STEP 2/3:
```javascript
function mapStateToProps(state) {
	return {
		book: state.activeBook
	}; 
}
```
- Refer to reducers/index.js properties (in this case it is **activeBook**) to refer to the piece of state

- Connect to store: STEP 3/3: 
```javascript
export default connect(mapStateToProps)(BookDetail); 
```
- Connect(function)(component) and it produces a container, which is aware of the state contained by redux 

_______________________________________________

### Conditional Rendering 

- Because previously we connected state to props via the function mapStateToProps(state) { return { book: state.activeBook };}, we can now use **this.props.book** in **src/containers/book-detail.js** like so: 

```javascript
class BookDetail extends Component {
	render() {
		return (
			<div>
				<h3>Details for:</h3>
				<div>{this.props.book.title}</div>
			</div>
			); 
	}
}
```

- Refreshing the browser shows an error: **Cannot read property 'title' of null at BookDetail**
- Our application state is assembled entirely by all our reducers. 
- When the app first starts up, user has not clicked on anything and state = null
- When we use {this.props.book.title} we are calling null.title which throws an error because Redux expects some property to be defined 
- Solution: Add intial check to the **render()** method: 

```javascript
class BookDetail extends Component {
	render() {
		if (!this.props.book) {
			return <div>Select a book to get started.</div>
		}
		return (
			<div>
				<h3>Details for:</h3>
				<div>{this.props.book.title}</div>
			</div>
			); 
	}
}
```

- Add a method to check if state = null and prompt the user to do an action 
- Once the user clicks on a book, it will update our app state and cause the container to re-render and state will now be defined 

_______________________________________________

### Reducers and Actions Review

- State in redux is a **single plain Javascript object**
- Application state is **completely different** than a component state, not connected at all 
- Component can still do stuff like this.state.something and this.setState({thing: 'thing'})
- Application state is formed by reducers
- Our Reducers all get tied together in src/reducers/index.js under the **combineReducers()** method: 

```javascript
import { combineReducers } from 'redux';
import BooksReducer from './reducer_books'; 
import ActiveBook from './reducer_active_book';

const rootReducer = combineReducers({
	books: BooksReducer,
	activeBook: ActiveBook
});

export default rootReducer;

```

- For each **key** in our **combineReducers** object, we assign a reducer as its **value**, which is then rsponsible for creating a particular piece of state 
- So in the above, whatever **ActiveBook (value)** returns will be available as our **activeBook (key)** piece of state
- When an **action** is dispatched, it flows through **all** the different Reducers in our app and each Reducer has the option to return a different piece of state than usual based on the type of action that was received 
- **Action Creators** are just simple functions that returns an **action**, and an action is just a **plain Javascript object**
- e.g. src/actions/index.js: 
```javascript 
export function selectBook(book) {
	// selectBook is an ActionCreator, it needs to return an action, an object with type property
	return (an action) {
		type: 'BOOK_SELECTED', 
		//type is always in uppercase and usually a string
		payload: book 
		// piece of data that describes more information about the action undertaken 
	}; 
}
```
- An **action** must always have a **type** defined and they can have **payload** or any other properties 

_______________________________________________

### End of Section 

- src/index.js: 
```javascript
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
import { createStore, applyMiddleware } from 'redux';

import App from './components/app';
import reducers from './reducers';

const createStoreWithMiddleware = applyMiddleware()(createStore);

ReactDOM.render(
  <Provider store={createStoreWithMiddleware(reducers)}>
    <App />
  </Provider>
  , document.querySelector('.container'));
```

- src/actions/index.js:

```javascript
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
import { createStore, applyMiddleware } from 'redux';

import App from './components/app';
import reducers from './reducers';

const createStoreWithMiddleware = applyMiddleware()(createStore);

ReactDOM.render(
  <Provider store={createStoreWithMiddleware(reducers)}>
    <App />
  </Provider>
  , document.querySelector('.container'));
```

- src/components/app.js:

```javascript
import React, { Component } from 'react';
import BookList from '../containers/book-list'; 
import BookDetail from '../containers/book-detail'; 

export default class App extends Component {
  render() {
    return (
      <div>
      <BookList />
      <BookDetail />
      </div>
    );
  }
}
```

- src/containers/book-detail.js:

```javascript
import React, { Component } from 'react'; 
import { connect } from 'react-redux'; //Connect to store: STEP 1/3

class BookDetail extends Component {
	render() {
		if (!this.props.book) {
			return <div>Select a book to get started.</div>
		}
		return (
			<div>
				<h3>Details for:</h3>
				<div><b>Title: </b>{this.props.book.title}</div>
				<div><b>Pages: </b>{this.props.book.pages}</div>
			</div>
			); 
	}
}

//Connect to store: STEP 2/3
function mapStateToProps(state) {
	return {
		book: state.activeBook //refer to reducers/index.js properties to refer to the piece of state
	}; 
}

//Connect to store: STEP 3/3
export default connect(mapStateToProps)(BookDetail); 
// connect(function)(component) and it produces a container, which is aware of the state contained by redux 
```

- src/containers/book-list.js:

```javascript
import React, { Component } from 'react'; 
import { connect } from 'react-redux'; //import connect function from react-redux
import { selectBook } from '../actions/index'; //import selectBook function (action creator) 
import { bindActionCreators } from 'redux'; 
// bindActionCreators is a function that ensures that the action generated by the action creator ends up flowing through all the reducers 



class BookList extends Component {
	renderList() {
		return this.props.books.map((book) => {
			return (
				<li 
					key={book.title} 
					onClick={() => this.props.selectBook(book)}
					className="list-group-item">
					{book.title}
				</li>
			);
		});
	}
	
	render() {
		return (
			<ul className="list-group col-sm-4">
				{this.renderList()}
			</ul>
			)
	}
}

function mapStateToProps(state) {
	// this function is the glue between react and redux 
	// takes in the application state as an arguement 
	// whatever gets returned from here will show up as props inside of BookList container above 
	return {
		books: state.books
	}; 
}

function mapDispatchToProps(dispatch) {
	// Whenever selectBook is called, the result should be passed to all reducers 
    // Anything returned from this function will end up as props on the BookList container 
    // Now we can use this.props.selectBook in the above container and this will call our selectBook action creator
	return bindActionCreators({ selectBook: selectBook }, dispatch); 
}


//Promote BookList from a component to a container - it needs to know about this new dispatch method, selectBook. 
//Makes it available as a prop. 
export default connect(mapStateToProps, mapDispatchToProps)(BookList); 
// connect(function)(component) and it produces a container, which is aware of the state contained by redux 
```

- src/reducers/index.js:

```javascript
import { combineReducers } from 'redux';
import BooksReducer from './reducer_books'; 
import ActiveBook from './reducer_active_book';

const rootReducer = combineReducers({
	books: BooksReducer,
	activeBook: ActiveBook
});

export default rootReducer;
```

- src/reducers/reducer_active_book.js:

```javascript
// 'State' argument is not application state, it refers only to the state that this reducer is responsible for 
export default function(state = null, action) {
	switch(action.type) {
	case 'BOOK_SELECTED': 
		return action.payload; 
	}
	return state; 
}

// In the above, if the action has a type matching 'BOOK_SELECTED', return action.payload (book), 
// If the action is anything else, return the current state

// All reducers get 2 arguments: state and action 
// When we boot the app up and the user has not clicked on anything, undefined will be returned
// Redux does not allow us to return undefined and will throw an error
// We have to set default state a null (above) 

// Important to never muatate our current state to provide a new version of the state 
// The object that we return from our reducer should always be 100% fresh and clean 
```

- src/reducers/reducer_books.js:

```javascript
export default function() {
	return [
		{ title: 'Javascript: The Good Parts', pages: "800" }, 
		{ title: "Harry Potter",  pages: "678" }, 
		{ title: "The Dark Tower",  pages: "324"  },
		{ title: "Eloquent Ruby" ,  pages: "234" }
	]
}
```































